Here are queries for things involving notes and related tables. Explanations below.

### note_npi_retrieve_multple.sql

This query pulls back the notes and their persistent IDs, along with associated titles based on the archival object ID and/or the resource ID and/or the persistent ID. This was created for API updates in the Public User Interface based on persistent ID and record URI. NOTE: If you are new to SQL, you'll want to look at [syntax for AND, OR, NOT operators](https://www.w3schools.com/sql/sql_and_or.asp), specifically about combining AND, OR, and NOT since this query takes advantage of that functionality. 

*What is going on?*
+ One of the tables with a long name (`note_persistent_id`) uses an alias throughout the query to save typing and such. For more information on aliases and how they work, you can read [here](https://www.w3schools.com/sql/sql_alias.asp "SQL Alias syntax").
+ The text of notes is kept in the `note` table in the, you guessed it, `notes` column. 
+ For identification purposes, you'll want the titles for the resource record or the archival objects record. This is especially true if your repository has persistent IDs that are not unique across the repository which is common with persistent IDs not automatically generated by ArchivesSpace. (E.g. legacy data that was imported.) If you are solely looking for notes in resource records or in archival object records, you can drop the appropriate `resource.title` or `archival_object.title` from the query.
+ Persistent IDs are not stored in the `note` table, but in their own table, `note_persistent_id`, in the `persistent_id` column. 
+ We're pulling this from the `note` table because it's the one with the information we need and it's common to all tables being called.
+ `note` is easily joined to all the other tables being called from due to it containing ID information for `resource` and `archival_object`, and having its own ID located in `npi`. For more information on `LEFT JOIN`, take a look [here](https://www.w3schools.com/sql/sql_join_left.asp "SQL LEFT JOIN syntax")
+ This is for multiple records, so we're using IN for any part of the WHERE clause. For more information on the `IN` operator, read [here](https://www.w3schools.com/sql/sql_in.asp "SQL IN operator"). 

There's a lot commented out because you may be choosing what you need. I'm going to start with the WHERE clause and then look back at the SELECT statement

*`WHERE` statement*
+ This query can be used whether you have the `npi.persistent_id`, the `archival_object.id`, the `resource.id`, or some combination of the three. I originally wrote this query for quality control checking and wanted to narrow down my results. I also really needed the IDs for the resource and archival object records because some of our legacy data used repeating persistent IDs. 
+ If you have the `archival_object.id`, are not working with resource records, and need the persistent IDs for the notes you need, drop `npi.persistent_id IN ()` from the `WHERE` clause. Delete the `AND` and delete `OR resource.id IN ()`. Your final statement should look like `WHERE archival_object.id IN ()`. If the opposite is true and you are only working with resource records, you will do an opposite process and the final statement will be `WHERE resource.id IN ()`. Keep in mind that this will retrieve ALL notes attached to whatever ID you put in. 
+ If you have both `archival_object.id` and `resource.id` but need to retrieve the `npi.persistent_id`, delete `npi.persistent_id IN () AND` and the parentheses wrapping `archival_object.id IN () OR resource.id IN ()`. Your final statement should be `WHERE archival_object.id IN () OR resource.id IN (). Again, keep in mind that this will retrieve ALL notes attached to whatever ID you put in. 
+ If you have the `npi.persistent_id` information, but none of the archival object or resource information, simply delete the whole `AND` clause. 
+ If you use the `WHERE` statement as created, it will first look by persistent ID, then look for the archival object and resource information. You will want it to look for both the archival object and resource data equally, which is why order of operations and parentheses are important!

*`SELECT` statement*
+ Because I am working across all repos at Yale with updates, knowing the repository ID helps me out, especially if I need to filter out data for a specific repository. Therefore, I included both `archival_object.repo_id` and `resource.repo_id`. Again, if you're only working with archival objects or resources, you can delete the one you don't need. You also don't need these if you are only working with one repo.
+ This report is being generated for quality control of API updates done in Python. You could also use this report for generating information *for* API updates. I included `CONCAT` functions for both archival object and resource URIs. For more information on the `CONCAT` function, take a look [here](https://www.w3schools.com/sql/func_mysql_concat.asp "SQL CONCAT function"). The API documentation for ArchivesSpace is located [here](http://archivesspace.github.io/archivesspace/api/ "ArchivesSpace API Reference"). 
+ In the version of ASpace we have, we see the text in a JSON format which is very human readable. You might also see it as a blob, which will look like a random string of letters and numbers. In that case, you'll want to add the `CAST` function to the query that is currently commented out. For more information on how `CAST` works, take a look [here](https://www.w3schools.com/sql/func_sqlserver_cast.asp "SQL CAST function").
