Here are queries for things involving restrictions. Explanations below.

### get_restriction_info_ao
This query pulls back the notes, restriction types, restriction dates, and persistent IDs for archival objects based on the archival object id. This query was created for a cleanup project for Yale's implementation of the Public User Interface.

*What is going on?*
+ A few of the tables with long names (`rights_restriction`, `rights_restriction_type`,`note_persistent_id`) use aliases throughout the query to save typing and such. For more information on aliases and how they work, you can read [here](https://www.w3schools.com/sql/sql_alias.asp "SQL Alias syntax")
+ The `rights_restriction` table has the IDs for archival objects and resources. You will need to have that information to call the items back. I will add a set of queries to do that soon if you're not sure how to form it, but keep in mind that you'll be able to see archival object IDs at the end of a URL in your ArchivesSpace. For example, a link will look like http:///yourdomainname.com/resources/12/archival_object_129148 and the ID number will be that 129148.
+ Other information you will need to pull from `rights_restrictions` are the restriction note type (`accessrestrict` vs. `userestrict`), and any, if present, machine actionable dates.(`rr.begin`, `rr.end`)
+ Another important piece of information for restrictions is the type, whether it's limited by donor (`RestrictedSpecColl`), by repository/staff decision (`RestrictedCurApprSpecColl`), or because of its physical or technical condition (`RestrictedFragile`). This is stored in the `rights_restriction_type` table in the `restriction_type_id` column.
+ The free text information is stored as a note in ArchivesSpace. You'll find the text in the `note.notes` table and column. 
+ As the name implies, `rrt.restriction_type_id` uses an ID number to denote the type of restriction rather than straight ahead text. The ID number for the type is probably not useful if you don't have its enumeration memorized. Enumerations of ID numbers for `restriction_type_id` and other similar type descriptions (e.g. `date.date_type_id`, `resource.language_id`) is stored in the `enumeration_value` table. Therefore, you will want to call the `enumeration_value.value` to get the actual type name. 
+ Our starting point for the `FROM` is `rights_restriction` as that is the main basis of our information.
+ The `LEFT JOIN`s form a linking pattern based on the commonalities. The common key between `note` and `rights_restriction` is the archival object ID that you are providing. The `rights_restriction_type` uses the `rights_restriction.id` that they both record. The `enumeration_value.id` uses the common number that is stored in the `rrt.restriction_type_id`. For more information on `LEFT JOIN`, take a look [here](https://www.w3schools.com/sql/sql_join_left.asp "SQL LEFT JOIN syntax")
+ Finally, you can put in the archival objects you specifically need information for! Since we had a list, I'm using the `IN` operator. If you just need one specific object for some strange reason, replace `IN` with `=` and you can put the ID number in. For more information on the `IN` operator, read [here](https://www.w3schools.com/sql/sql_in.asp "SQL IN operator"). 

*Commented out parts*
+ Our cleanup project used the data we pulled from the SQL tables to populate CSV speadsheets to edit existing restriction notes. For those scripts to work we need the archival objects information. Therefore, I added the `archival_object.title` to call information from that table. Because you might just be checking information in bulk, I commented it out and pulled the archival object ID from the `rights_restriction` table. You might also want to delete the comment out if you just want the title present to make sure you're looking at the correct thing.
+ In our project, we were planning on using the persistent ID of the note to edit them. The persistent ID is stored in its own table, `note_persistent_id`. 
+ For API updates to work, you need to have the correct API endpoint. The API documentation is located [here](http://archivesspace.github.io/archivesspace/api/ "ArchivesSpace API Reference"). Therefore, I add a `CONCAT` function pulling together the same structure. If you don't need the API endpoint, you can leave it commented out. Note that this is not the same thing as the URL you would use to get to the archival object record in the SUI or PUI. For more information on the `CONCAT` function, take a look [here](https://www.w3schools.com/sql/func_mysql_concat.asp "SQL CONCAT function")
+ In the version of ASpace we have, we see the text in a JSON format which is very human readable. You might also see it as a blob, which will look like a random string of letters and numbers. In that case, you'll want to add the CAST function to the query that is currently commented out. For more information on how CAST works, take a look [here](https://www.w3schools.com/sql/func_sqlserver_cast.asp "SQL CAST function")
+ Further `LEFT JOIN` explanantions:  For the `note_persistent_id`, you need the `note.id` that the `note` table is linked back to the `rights_restriction`. For the `CONCAT` to work, you need the `archival_object.repo_id` and the `archival_object.id` stored in that table. In this case, we do a `JOIN` based on the `rights_restriction.archival_object_id`. 
